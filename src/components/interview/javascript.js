/***********
1.引起内存泄漏的操作有哪些
1.1 定义：什么是内存泄漏？
    内存泄漏（Memory Leak）指的是：
        程序中已经不再使用的内存，由于某些原因没有被释放，导致它仍然被占用。
    换句话说：
        有些对象或数据，本该被垃圾回收（GC）机制清理掉，但因为还有引用存在，GC 认为它还“有用”，于是一直留在内存中。
    最终结果是：
        内存占用越来越高；
        页面越来越卡；
        甚至浏览器崩溃（尤其是长时间运行的单页应用）
1.2 JS 垃圾回收机制
    垃圾回收（GC, Garbage Collection）是指自动管理内存的过程，它会自动回收不再使用的内存资源，避免内存泄漏和提高应用性能。
    垃圾回收的目的是为了自动检测和清理那些不再使用的对象和资源，从而释放内存。
    这些对象一旦不再被引用，垃圾回收器就会将它们标记为可回收的，并且在适当的时候释放这些对象占用的内存空间

    JavaScript 的垃圾回收机制主要依赖于两种技术：标记清除（Mark-and-Sweep）和引用计数（Reference Counting）
    标记清除: 垃圾回收器通过从根对象开始，遍历所有'可达的对象'并标记它们为“存活”。然后，回收那些没有被标记的对象。
    引用计数：每个对象都有一个引用计数器，记录有多少个引用指向该对象。当引用计数为 0 时，表示对象不再使用，可以被回收。

1.3 常见的内存泄漏问题
    尽管垃圾回收机制已经尽可能地优化了内存管理，但开发者依然需要注意一些常见的内存泄漏问题：
        全局变量：全局变量未释放，不小心声明的全局变量会导致无法回收的对象，尤其是动态创建的全局变量。
        闭包：闭包引用未释放，闭包会保存外部函数的作用域，可能导致一些不再使用的变量无法被垃圾回收器回收。
        DOM引用：长时间持有 DOM 元素的引用，尤其是在单页应用中，可能会导致内存泄漏。
            DOM 从文档中被移除，但 JS 仍有对 DOM 引用，因此需要在移除 DOM 前解除事件绑定
        定时器和回调：如果使用了 setTimeout 或 setInterval，并且没有正确清理它们，可能会导致内存泄漏。因此需要在组件销毁时清理
        事件监听器：没有解绑的事件监听器会继续保持对 DOM 元素的引用，导致对象无法被回收。
1.4 如何查看内存泄漏
        我排查内存泄漏最常用的方法是用 Chrome DevTools 的 Memory 面板。
        我会多次进行 Heap Snapshot，对比对象数量变化。
        如果看到某些对象（比如组件实例或 DOM 节点）在关闭页面后仍然存在，就说明有泄漏。
        另外也会用 Performance 面板看内存曲线是否持续上升。
 * 
 * 
 * 
 * 
 */